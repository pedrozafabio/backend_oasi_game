const Character = require("../models/Character");
const Item = require("../models/Item");
const ErrorResponse = require("../utils/ErrorResponse");
const AsyncHandler = require("../middleware/AsyncHandler");

/**
 * @swagger
 * /characters:
 *   get:
 *     summary: Get all characters
 *     description:
 *       "Required roles: `admin`"
 *     tags:
 *       - Characters
 *     parameters:
 *       - name: body
 *         in: body
 *         required: true
 *         schema:
 *           type: object
 *           required:
 *             - username
 *             - password
 *           properties:
 *             username:
 *               type: string
 *             password:
 *               type: password
 *           example: {
 *             "username": "someUsasda",
 *             "password": "somePassword"
 *           }
 *     responses:
 *       200:
 *         schema:
 *           type: object
 *           properties:
 *             id:
 *               type: integer
 *             username:
 *               type: string
 *         examples:
 *           application/json: {
 *             "id": 1,
 *             "username": "someuser"
 *           }
 *       409:
 *         description: When the username is already in use
 */

//@desc Get all characters
//@route GET /api/v1/characters
//@access Public
exports.GetCharacters = (req, res, next) => {
	res.status(200).json(res.advancedResults);
};

//@desc Get character by ID
//@route GET /api/v1/characters/:characterId
//@access Public
exports.GetCharacterById = AsyncHandler(async (req, res, next) => {

	const character = await Character.findById(req.params.characterId)
		.populate('ponchoSize')
		.populate('headTexture')
		.populate('ponchoTexture')
		.populate('bodyColor')
		.populate('headColor')
		.populate('friends', 'username');

	if (!character) {
		return res.status(400).json({ success: false });
	}

	res.status(200).json({
		success: true,
		data: character
	});
});

/**
 * @swagger
 * /characters/ida:
 *   get:
 *     summary: Get character by Midia Ninja's IDA
 *     description:
 *       "IDA is generated by MÃ­dia Ninja's API."
 *     tags:
 *       - Characters
 *     parameters:
 *     responses:
 */
exports.GetCharacterByIda = AsyncHandler(async (req, res, next) => {

	console.log(res.resToken);

	const character = await Character.findOne({ida : res.resToken.ida})
		.populate('ponchoSize')
		.populate('headTexture')
		.populate('ponchoTexture')
		.populate('bodyColor')
		.populate('headColor')
		.populate('friends', 'username');

	if (!character) {
		return res.status(400).json({ success: false });
	}

	res.status(200).json({
		success: true,
		data: character
	});
});

//@desc Create character
//@route POST /api/v1/characters
//@access Public
// exports.CreateCharacter = AsyncHandler(async (req, res, next) => {
// 	const character = await createCharacter(req.body, res.resToken);

// 	res.status(201).json({
// 		success: true,
// 		data: character
// 	});
// });

//@desc     Update a character
//@route    PUT /api/v1/characters/:characterId
//@access   Private
exports.UpdateCharacter = AsyncHandler(async (req, res, next) => {
	let character = await Character.findById(req.params.characterId);

	// console.log(character);

	if (!character) {
		next(new ErrorResponse(`Character not found with id of ${req.params.characterId}`, 404));
	}
	else {
		// else if (character.user.toString() !== req.user.id && req.user.role !== "admin") {
		// 	next(new ErrorResponse(`User ${req.params.id} is not authorized to update this character`, 401));
		// }

		const filter = { _id: req.params.characterId };

		character = await Character.findOneAndUpdate(filter, req.body, {
			new: true,
			runValidators: true
		})
			.populate('ponchoSize')
			.populate('headTexture')
			.populate('ponchoTexture')
			.populate('bodyColor')
			.populate('headColor')
			.populate('friends', 'username');

		console.log(req.params.characterId);

		res.status(200).json({ success: true, data: character });
	}
});

//@desc     Delete a character
//@route    DELETE /api/v1/characters/:characterId
//@access   Admin
exports.DeleteCharacter = AsyncHandler(async (req, res, next) => {
	const character = await Character.findById(req.params.characterId);

	if (!character) {
		next(new ErrorResponse(`Character not found with id of ${req.params.characterId}`, 404));
	}
	else {
		// else if (character.user.toString() !== req.user.id && req.user.role !== "admin") {
		// 	next(new ErrorResponse(`User ${req.params.id} is not authorized to delete this character`, 401));
		// }
		character.remove();
		res.status(200).json({ success: true, data: {} });
	}
});

/**
 * @swagger
 * /characters/:characterId/:itemId:
 *   post:
 *     summary: Add an existing item to a character
 *     description:
 *       "Item must be in Item database."
 *     tags:
 *       - Characters
 *     parameters:
 *     responses:
 */
exports.AddItemToCharacter = AsyncHandler(async (req, res, next) => {
	let character = await Character.findById(req.params.characterId);

	if (!character) {
		next(new ErrorResponse(`Character not found with id of ${req.params.characterId}`, 404));
	}
	else {

		const item = await Item.findOne({itemId : req.params.itemId});

		if (!item) {
			next(new ErrorResponse(`Item not found with id of ${req.params.itemId}`, 404));
		}
		else{

			if(item.price > 0){
				if(!character.itemsIdList.includes(item.itemId)){
					next(new ErrorResponse(`Character ${character.username} hasn't bought the item ${item.name}`, 400));
				}
			}

			var selectedCategory = "";
			if(item.colorId != null)
				selectedCategory = item.category + "Color";
			else if(item.sizeId != null)
				selectedCategory = item.category + "Size";
			else if(item.textureId != null)
				selectedCategory = item.category + "Texture";

			const filter = { _id: req.params.characterId };

			var body = {};

			body[selectedCategory] = item._id;

			character = await Character.findOneAndUpdate(filter, body, {
				new: true,
				runValidators: true
			})
				.populate('ponchoSize')
				.populate('headTexture')
				.populate('ponchoTexture')
				.populate('bodyColor')
				.populate('headColor')
				.populate('friends', 'username');

			res.status(200).json({ success: true, data: {character} });
		}
	}
});

exports.GiveTakePoints = AsyncHandler(async (req, res, next) => {
	let character = await Character.findById(req.body.characterId);

	if (!character) {
		next(new ErrorResponse(`Character not found with id of ${req.params.characterId}`, 404));
	}

	const finalPoints = character.points + req.body.points;

	if(finalPoints < 0){
		next(new ErrorResponse(`The final amount of the player's points cannot be less than 0.`, 400));
	}

	character = await GivePoints(character, finalPoints);

	res.status(200).json({ success: true, data: character });

});

exports.AddFriend = AsyncHandler(async (req, res, next) => {

	console.log(res.resToken);

	let character = await Character.findOne({ida : res.resToken.ida});

	if (!character) {
		next(new ErrorResponse(`Character not found with id of ${req.params.characterId}`, 400));
	}

	let friend = await Character.findOne({username : req.params.friendUserName});

	if(!friend){
		next(new ErrorResponse(`Friend with username ${req.params.friendUserName} not found.`, 404));
	}

	//Check if they are already friends
	if(character.friends.includes(friend._id)){
		next(new ErrorResponse(`The user ${req.params.friendUserName} is already your friend.`, 400));
	}

	else if(character.username === friend.username){
		next(new ErrorResponse(`You cannot be friends with yourself.`, 400));
	}

	else{

		//Making new updated friends lists for both players
		let characterFriendsList = character.friends;
		characterFriendsList.push(friend._id);

		let friendFriendsList = friend.friends;
		friendFriendsList.push(character._id);

		friend = await Character.findOneAndUpdate({username : req.params.friendUserName}, {friends: friendFriendsList}, {
			new: true,
			runValidators: true
		});

		character = await Character.findOneAndUpdate({ida : res.resToken.ida}, {friends: characterFriendsList}, {
			new: true,
			runValidators: true
		})
			.populate('ponchoSize')
			.populate('headTexture')
			.populate('ponchoTexture')
			.populate('bodyColor')
			.populate('headColor')
			.populate('friends', 'username');

	}

	res.status(200).json({
		success: true,
		data: character
	});
});


//Pure functions

exports.GetRoleByIda = async(resToken) => {

	let character = await Character.findOne({ida : resToken.ida});

	if(!character){
		//Create a standard character and set initial items by ID
		const charData = {
			role: "user",
			points: 1000,
			ponchoSize: "5f8d9d02fb2074432f854586",
        	headTexture: "5f8d9e35fb2074432f854589",
			ponchoTexture: "5f8d9f45fb2074432f85458e",
			bodyColor: "5f8d9fb8fb2074432f854591",
			headColor: "5f8d9ffcfb2074432f854596"
		}

		character = await createCharacter(charData, resToken);
	}

	return {
		_id: character._id,
		role: character.role
	};
};

createCharacter = async(body, resToken) => {
	body.username = resToken.username;
	body.ida = resToken.ida;


	const character = await Character.create(body);

	return character;
}

GivePoints = async (character, finalPoints) => {

	const body = {
		points: finalPoints
	};

	const filter = { _id: character._id };

	character = await Character.findOneAndUpdate(filter, body, {
		new: true,
		runValidators: true
	});

	return character;
}